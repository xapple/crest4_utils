#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Written by Lucas Sinclair.

A script to create new taxonomic databases formatted for use in `crest4`.

This script takes as input a "TSV" file. This file is typically generated by
ARB.

This script generates the following output:

1) A `.map` file
2) A `.names` file.
3) A `.tre` file

The TSV file to parse as input contains three columns:

    1) Accession.
    2) Path in the tree of life.
    3) Name of the taxa.

Here is an example excerpt:

    OQ071219	Main genome/Eukaryota/Amorphea/Metazoa/Mollusca/Scaphopoda/Dentaliida/Dentaliidae/Antalis/Antalis occidentalis	Antalis occidentalis
    OQ071220	Main genome/Eukaryota/Amorphea/Metazoa/Mollusca/Bivalvia/Mytiloida/Mytilidae/Dacrydium/Dacrydium vitreum	Dacrydium vitreum
    OQ071221	Main genome/Eukaryota/Amorphea/Metazoa/Mollusca/Bivalvia/Lucinida/Thyasiridae/Leptaxinus/Leptaxinus minutus	Leptaxinus minutus

The third column is always ignored, but it generally matches the last item
in the taxonomic path (second column).

The taxonomic path in the file uses the "/" character as a separator, but the
"/" character appears many times within the name of different taxa,
resulting in a faulty parsing.

Here inside a species name for instance:

AB023970        Main genome/Bacteria/Bacteria (superkingdom)/Terrabacteria/Firmicutes/Clostridia/Peptostreptococcales-Tissierellales/Peptostreptococcaceae/Peptoclostridium/4/[Clostridium] hiranonis      [Clostridium] hiranonis

And here inside a strain name for instance:

AJ784845        Main genome/Bacteria/Bacteria (superkingdom)/Terrabacteria/Firmicutes/Bacilli/Bacillales/Bacillaceae/Bacillus/Bacillus sp. Con a/4 Bacillus sp. Con a/4

So, the script will also identify segments that are just numbers preceded
by '/' at the end of taxon names and keep them inside the name.

We also need to check that we don't create leaves before being at the end of
a taxonomic path. If the species name has already been seen but the genus name
is novel for instance, we might create a leaf at the genus. This can happen if
the same species name exists in different parts of the tree of life.

The `.map` file consists of a CSV file with two columns e.g. `6082,HM392072`
linking the accession to the node number.

The `.tre` file is a Newick format and contains something like:
`(2,3,4,(((14,17,18,3513,8860...` etc.

The `.names` file is created as a CSV file with three columns such as:
`10,Actinopteri,0.85`.

It specifies the ID of a node and links it to the similarity fraction that
should be used as a threshold when assigning (this is done by first checking
its distance from the root).

This script has to add the percentage values to the third column of
the `.names ` file. It should be default values computed just by counting
the number of ranks for the start.

The deepest rank such as species should be 0.99 and then progressively get
lower to 0.85.

The domain level (e.g., Bacteria) should always be 0.0, however.

'Root',          # 0     | n/a
'Genome',        # 1     | 0.0
'Domain',        # 2     | 0.0
'Superkingdom'   # 3     | 0.85
'Kingdom',       # 4     | 0.87
'Phylum',        # 5     | 0.89
'Class',         # 6     | 0.91
'Order',         # 7     | 0.93
'Family',        # 8     | 0.95
'Genus',         # 9     | 0.97
'Species',       # 10    | 0.99

Typically, you would call this script like this:

    $ crest4_utils/make_new_crest_db.py \
      crest4_utils/example_files/18S_curated_141222_GenBank_nds.tsv
"""

# Built-in modules #
import os, functools, csv, gzip

###############################################################################
class AccessionTSV:
    """
    Represents a TSV file with three columns. Example line:
    OQ071217    Main genome/Eukaryota/.../Antalis agilis    Antalis agilis
    """

    # ------------------------------ Methods -------------------------------- #
    def __init__(self, path):
        """Here we record the full path of the input file."""
        self.tsv_path = path

    def __iter__(self):
        """Here we create a CSV reader object on the input file."""
        # Check if the file is gzipped by reading the magic number #
        with open(self.tsv_path, 'rb') as f:
            magic_number = f.read(2)
        # Open with gzip if the magic number matches #
        if magic_number.startswith(b'\x1f\x8b'):
            file_obj = gzip.open(self.tsv_path, 'rt')
        else:
            file_obj = open(self.tsv_path)
        # Return the reader #
        return csv.reader(file_obj, delimiter='\t')

    def __call__(self):
        assert self.tree
        return self.tree_file(), self.map_file(), self.names_file()

    # ----------------------------- Properties ------------------------------ #
    @property
    def output_dir(self):
        """Where to store all the outputs."""
        return os.path.dirname(self.tsv_path) + '/'

    @property
    def output_prefix(self):
        """Full name of the input file without the last extension."""
        return os.path.splitext(self.tsv_path)[0]

    @functools.cached_property
    def tree(self):
        """Build the tree in memory using all entries."""
        # Import #
        from ete3 import TreeNode
        # Initialize a hashmap of the nodes by number #
        self.by_nums = {}
        # Initialize the hashmap with numbers (of the nodes) by names #
        self.by_names = {}
        # Initialize the node number to zero #
        current_num = 0
        # Set the root name to "meta" #
        root_name = "meta"
        # Make the root of the tree #
        self.root_node = TreeNode(name=current_num)
        self.root_node.add_feature('taxa', root_name)
        # Iterate over rows #
        for i, row in enumerate(self):
            # Check that the row has three columns #
            if len(row) != 3:
                msg = "The row %i does not contain three columns:\n%s"
                raise Exception(msg % (i+1, row))
            # Parse the row (the full_name is ignored) #
            acc, path, full_name = row
            # Check we have an accession #
            if not acc:
                msg = "This row does not contain an accession:\n%s"
                raise Exception(msg % row)
            # Split the path into a list #
            path = path.split('/')
            # Check we have a path #
            if not path:
                msg = "This row does not contain a taxonomic path:\n%s"
                raise Exception(msg % row)
            # Join numerical segments back with their preceding segments #
            fixed_path = []
            for i, segment in enumerate(path):
                if segment.isdigit() and i > 0:
                    fixed_path[-1] = fixed_path[-1] + '/' + segment
                else:
                    fixed_path.append(segment)
            # Always start from the same root node before looping #
            parent = self.root_node
            # Iterate over the path #
            for name in fixed_path:
                # Check if the node exits, but only in the immediate children #
                for child in parent.get_children():
                    if child.taxa == name:
                        # Retrieve the node if it exists already #
                        node = child
                        break
                else:
                    # Increment node number #
                    current_num += 1
                    # Append to the parent #
                    node = parent.add_child(name=current_num)
                    # Add the name #
                    node.add_feature('taxa', name)
                # Set the parent for the next iteration #
                parent = node
            # When we are on the last step of the path, add the accession #
            node.add_feature('acc', acc)
        # Return #
        return self.root_node

    # ---------------------------- Composition ------------------------------ #
    @functools.cached_property
    def map_file(self):
        return MapFile(self)

    @functools.cached_property
    def names_file(self):
        return NamesFile(self)

    @functools.cached_property
    def tree_file(self):
        return TreeFile(self)

###############################################################################
class OutputFile:
    """Parent class for all outputs generated by the script."""
    extension = '.txt'

    # ------------------------------ Methods -------------------------------- #
    def __init__(self, tsv_path):
        self.acc_tsv = tsv_path

    def __call__(self):
        with open(self.output_path, 'w') as handle:
            handle.writelines(self.lines())
        return self.output_path

    # ----------------------------- Properties ------------------------------ #
    @property
    def output_path(self):
        return self.acc_tsv.output_prefix + self.extension

    @property
    def lines(self):
        raise NotImplementedError("Please implement this in all subclasses.")

###############################################################################
class MapFile(OutputFile):
    """Represents a CSV file with two columns e.g. `6082,HM392072`."""
    extension = '.map'

    def lines(self):
        for leaf in self.acc_tsv.tree.iter_leaves():
            # Check if the leaf has an accession #
            if not hasattr(leaf, 'acc'): self.show_bad_leaf(leaf)
            # Return the line #
            yield str(leaf.name) + ',' + leaf.acc + '\n'

    def show_bad_leaf(self, leaf):
        # List the parents #
        msg  = "Leaf node %s (%s) is missing an accession ('%s')."
        path = [node.taxa for node in leaf.get_ancestors()]
        path = '/'.join(reversed(path))
        msg  = msg % (leaf.name, leaf.taxa, path)
        # We also want to see the children #
        more = '/'.join([node.taxa for node in leaf.get_children()])
        # Stop here #
        raise Exception(msg + "\nChildren: " + more)

###############################################################################
class NamesFile(OutputFile):
    """Represents a CSV file with three columns e.g. `101,Actinopteri,0.85`."""
    extension = '.names'

    @functools.cached_property
    def depth_to_smlrty(self):
        """
        Return a dictionary that links the depth of a node (which
        represents its distance from the root) to the similarity value
        that should be assigned. Looks like this:
            {3: 0.85,
             4: 0.87,
             5: 0.89, ... }
        """
        # Get the maximum depth #
        depth = lambda leaf: self.acc_tsv.tree.get_distance(leaf)
        max_depth = int(max(map(depth, self.acc_tsv.tree.iter_leaves())))
        # Build the dictionary #
        result = {d: round((0.99 - 0.02 * (max_depth - d)), 2)
                  for d in range(3, max_depth + 1)}
        # Special cases #
        result[0] = 0.0
        result[1] = 0.0
        result[2] = 0.0
        # Return #
        return result

    def lines(self):
        """The `node.name` here represents it's numerical ID here."""
        for node in self.acc_tsv.tree.traverse("levelorder"):
            depth  = node.get_distance(self.acc_tsv.tree)
            smlrty = self.depth_to_smlrty[depth]
            yield str(node.name) + ',' + node.taxa + ',' + str(smlrty) + '\n'

###############################################################################
class TreeFile(OutputFile):
    """Represents a Newick file e.g. `(2,3,4,(((14,17,18,3513,8860...`."""
    extension = '.tre'

    def __call__(self):
        self.acc_tsv.tree.write(format=8, outfile=self.output_path)
        return self.output_path

###############################################################################
if __name__ == '__main__':
    # Create a shell parser #
    import argparse
    parser = argparse.ArgumentParser()

    # Ask for the main argument #
    help_msg = "The path to the TSV file to process."
    parser.add_argument("input_tsv", help=help_msg, type=str)

    # Parse the shell arguments #
    args = parser.parse_args()
    tsv_path = args.input_tsv

    # Run it #
    acc_tsv = AccessionTSV(tsv_path)
    print(acc_tsv())

    # Show success #
    print("Success.")
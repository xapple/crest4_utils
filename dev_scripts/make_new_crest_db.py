#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Written by Lucas Sinclair.

A script to create new taxonomic databases formatted for use in `crest4`.

This script takes as input a "TSV" file. This file is typically generated by
ARB.

This script generates the following output:

1) A `.map` file
2) A `.names` file.
3) A `.tre` file

This script has to also add the percentage values to the third column of
`.names` file. It should be default values computed just by counting the
number of ranks for the start.

The deepest rank such as species should be 0.99 and then progressively get
lower to 0.85.

The domain level (e.g. Bacteria) should always be 0.0 however.

'Genome',        # 1     | n/a
'Domain',        # 2     | 0.0
'Superkingdom'   # 3     | 0.85
'Kingdom',       # 4     | 0.87
'Phylum',        # 5     | 0.89
'Class',         # 6     | 0.91
'Order',         # 7     | 0.93
'Family',        # 8     | 0.95
'Genus',         # 9     | 0.97
'Species',       # 10    | 0.99

The TSV file to parse contains three columns:

    1) Accession.
    2) Path in the tree of life.
    3) Name of the taxa.

The third column is always ignored, but it generally matches the last item
in the taxonomic path (second column).

Typically, you would call this script like this:

    $ crest4_utils/dev_scripts/make_new_crest_db.py crest4_utils/example_files/18S_curated_141222_GenBank_nds.tsv
"""

# Built-in modules #
import os, functools

###############################################################################
class AccessionTSV:
    """
    Represents a TSV file with three columns. Example:
    OQ071217    Main genome/Eukaryota/.../Antalis agilis    Antalis agilis
    """

    # ------------------------------ Methods -------------------------------- #
    def __init__(self, tsv_path):
        self.tsv_path = tsv_path

    def __iter__(self):
        import csv
        return csv.reader(open(self.tsv_path), delimiter='\t')

    def __call__(self):
        assert self.tree
        return self.tree_file(), self.map_file(), self.names_file()

    # ----------------------------- Properties ------------------------------ #
    @property
    def output_dir(self):
        return os.path.dirname(self.tsv_path) + '/'

    @property
    def output_prefix(self):
        return os.path.splitext(self.tsv_path)[0]

    @functools.cached_property
    def tree(self):
        """Build the tree in memory using all entries."""
        # Import #
        from ete3 import TreeNode
        # Initialize hashmap of the nodes by number #
        self.by_nums = {}
        # Initialize hashmap of the numbers (of the nodes) by names #
        self.by_names = {}
        # Initialize the node number to zero #
        current_num = 0
        # Get the name of the root #
        root_path = next(iter(self))[1].split('/')
        root_name = root_path[0]
        # Make the root of the tree #
        self.root_node = TreeNode(name=current_num)
        self.root_node.add_feature('taxa', root_name)
        # Add to the hashmaps #
        self.by_nums[current_num] = self.root_node
        self.by_names[root_name]  = current_num
        # Iterate over rows #
        for row in self:
            # Parse the row (the full_name is ignored) #
            acc, path, full_name = row
            # Split the path into a list #
            path = path.split('/')
            # Check that the first name of the path is the root #
            assert path[0] == root_name
            # Iterate over the path #
            for name in path:
                # Get the node if it exists #
                found_num = self.by_names.get(name)
                # Otherwise create it #
                if found_num is None:
                    # Increment node number #
                    current_num += 1
                    # Append to the parent #
                    node = parent.add_child(name=current_num)
                    # Add the name #
                    node.add_feature('taxa', name)
                    # Add to the hashmaps #
                    self.by_nums[current_num] = node
                    self.by_names[name] = current_num
                # Retrieve the node if it exists already #
                else: node = self.by_nums[found_num]
                # Set the parent for the next iteration #
                parent = node
            # If we are on a leaf, add the accession #
            else: node.add_feature('acc', acc)
        # Return #
        return self.root_node

    # ---------------------------- Composition ------------------------------ #
    @functools.cached_property
    def map_file(self):
        return MapFile(self)

    @functools.cached_property
    def names_file(self):
        return NamesFile(self)

    @functools.cached_property
    def tree_file(self):
        return TreeFile(self)

###############################################################################
class OutputFile:
    """Parent class for all outputs generated by the script."""

    # ------------------------------ Methods -------------------------------- #
    def __init__(self, acc_tsv):
        self.acc_tsv = acc_tsv

    def __call__(self):
        with open(self.output_path, 'w') as handle:
            handle.writelines(self.lines())
        return self.output_path

    # ----------------------------- Properties ------------------------------ #
    @property
    def output_path(self):
        return self.acc_tsv.output_prefix + self.extension

###############################################################################
class MapFile(OutputFile):
    """Represents a CSV file with two columns e.g. `6082,HM392072`."""
    extension = '.map'

    def lines(self):
        for leaf in self.acc_tsv.tree.iter_leaves():
            yield str(leaf.name) + ',' + leaf.acc + '\n'

###############################################################################
class NamesFile(OutputFile):
    """Represents a CSV file with three columns e.g `10,Actinopteri,0.85`."""
    extension = '.names'

    @functools.cached_property
    def depth_to_smlrty(self):
        """
        Return a dictionary that links the depth of a node (which
        represents its distance from the root) to the similarity value
        that should be assigned.
        """
        # Get the maximum depth #
        depth = lambda leaf: self.acc_tsv.tree.get_distance(leaf)
        max_depth = int(max(map(depth, self.acc_tsv.tree.iter_leaves())))
        # Build the dictionary #
        result = {d: round((0.99 - 0.02 * (max_depth - d)), 2)
                  for d in range(2, max_depth + 1)}
        # Special cases #
        result[0] = '0.0'
        result[1] = '0.0'
        # Return #
        return result

    def lines(self):
        for node in self.acc_tsv.tree.traverse("levelorder"):
            depth  = node.get_distance(self.acc_tsv.tree)
            smlrty = self.depth_to_smlrty[depth]
            yield str(node.name) + ',' + node.taxa + ',' + str(smlrty) + '\n'

###############################################################################
class TreeFile(OutputFile):
    """Represents a Newick file e.g. `(2,3,4,(((14,17,18,3513,8860...`."""
    extension = '.tre'

    def __call__(self):
        self.acc_tsv.tree.write(format=8, outfile=self.output_path)
        return self.output_path

###############################################################################
if __name__ == '__main__':
    # Create a shell parser #
    import argparse
    parser = argparse.ArgumentParser()

    # Ask for the main argument #
    help_msg = "The path to the TSV file to process."
    parser.add_argument("input_tsv", help=help_msg, type=str)

    # Parse the shell arguments #
    args = parser.parse_args()
    tsv_path = args.input_tsv

    # Run it #
    acc_tsv = AccessionTSV(tsv_path)
    print(acc_tsv())

    # Show success #
    print("Success.")